using System;
using System.Text;
using System.Collections.Generic;
using System.Linq;
using Loyc;               // (for IMessageSink, Symbol, etc.)
using Loyc.Collections;   // (many handy interfaces & classes)
using Loyc.Syntax.Lexing; // (for BaseLexer)
using Loyc.Syntax;        // (for BaseParser<Token>, LNode)

namespace MyLanguage
{
	using TT = TokenType;  // Abbreviate TokenType as TT
	using S = CodeSymbols;  // Abbreviate TokenType as TT

	partial class MyLexer : BaseLexer
	{
		TokenType _type;
		object _value;
		int _startIndex;

		LLLPG (lexer)
		{
			public token Token NextToken()
			{
				_startIndex = InputPosition;
				_value = null;
				@[ {_type = TT.Num;}                    Num
				 | {_type = TT.Newline;}                Newline
				 | {_type = TT.Id;}                     Id
				 | {_type = TT.Mul; _value = S.Mul;}    '*'
				 | {_type = TT.Div; _value = S.Div;}    '/'
				 | {_type = TT.Add; _value = S.Add;}    '+'
				 | {_type = TT.Sub; _value = S.Sub;}    '-'
				 | {_type = TT.Set; _value = S.Assign;} ':'? '='
				 | {_type = TT.LParen;}                 '('
				 | {_type = TT.RParen;}                 ')'
				 | {_type = TT.Spaces;}                 (' '|'\t')+
				 | {_type = TT.Semicolon;}              ';'
				 | error {_type = TT.EOF;} 
				      [_ {_type = TT.Unknown;}]?
				 ];
				return new Token((int) _type, _startIndex, InputPosition - _startIndex, NodeStyle.Default, _value);
			}

			extern token Newline @[ '\r' '\n'? | '\n' ];

			private token Id() @[
				('a'..'z'|'A'..'Z'|'_')
				('a'..'z'|'A'..'Z'|'_'|'0'..'9')*
				{_value = GSymbol.Get(CharSource.Slice(_startIndex, InputPosition - _startIndex).ToString());}
			];

			private token Num() @[
				{bool dot = false;}
				('.' {dot = true;})?
				'0'..'9'+
				(&!{dot} '.' '0'..'9'+)?
				{_value = double.Parse(CharSource.Slice(_startIndex, InputPosition - _startIndex).ToString());}
			];
		}
	}
}
