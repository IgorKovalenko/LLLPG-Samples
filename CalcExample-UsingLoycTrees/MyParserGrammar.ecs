using System;
using System.Text;
using System.Collections.Generic;
using System.Linq;
using Loyc;               // (for IMessageSink, Symbol, etc.)
using Loyc.Collections;   // (many handy interfaces & classes)
using Loyc.Syntax.Lexing; // (for BaseLexer)
using Loyc.Syntax;        // (for BaseParser<Token>, LNode)

namespace MyLanguage
{
	using TT = TokenType;  // Abbreviate TokenType as TT
	using S = CodeSymbols; // To access symbols commonly used in Loyc trees

	public partial class MyParser : BaseParser<Token>
	{
		LLLPG (parser(laType(TokenType), matchType(int)))
		{
			alias("(" = TT.LParen);
			alias(")" = TT.RParen);
			alias("^" = TT.Exp);
			alias("*" = TT.Mul);
			alias("/" = TT.Div);
			alias("+" = TT.Add);
			alias("-" = TT.Sub);
			alias("=" = TT.Set);

			LNode BinOp(Symbol type, LNode lhs, LNode rhs)
			{
				return F.Call(type, lhs, rhs, lhs.Range.StartIndex, rhs.Range.EndIndex);
			}

			public rule LNode Start() @[ e:=Expr EOF {return e;} ];

			private rule LNode Expr() @[
				e:=AddExpr 
				[ "=" rhs:=Expr {e = BinOp(S.Set, e, rhs);} ]?
				{return e;}
			];

			private rule LNode AddExpr() @[
				e:=MulExpr
				[ op:=("+"|"-") rhs:=MulExpr {e = BinOp((Symbol) op.Value, e, rhs);} ]*
				{ return e; }
			];

			private rule LNode MulExpr() @[ 
				e:=PrefixExpr
				[ op:=("*"|"/") rhs:=PrefixExpr 
				  {e = BinOp((Symbol) op.Value, e, rhs);}
				]*
				{return e;}
			];

			private rule LNode PrefixExpr() @
				[ minus:="-" e:=Term {return F.Call(S.Sub, e, minus.StartIndex, e.Range.EndIndex);}
				| e:=Term            {return e;}
				];

			private rule LNode Term() @[
				// Supports "mathy" expressions like 3(x-1)(x+1)
				e:=Atom
				[ rest:=Atom {e = BinOp(S.Mul, e, rest);} ]*
				{ return e; }
			];

			private rule LNode Atom() @[
				{LNode r;}
				( t:=TT.Id          {r = F.Id(t);}
				| t:=TT.Num         {r = F.Literal(t);}
				| "(" r=Expr() ")" 
				| error             {r = F._Missing; Error(0, "Expected identifer, number, or (parens)");}
				)
				greedy [ 
					"^" e:=Atom // exponent
					{r = BinOp(S.XorBits, r, e);}
				]*
				{return r;}
			];
		}
	}
}
